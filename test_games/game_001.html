<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbital Siege</title>
    <style>
        :root {
            --primary: #00f3ff;
            --danger: #ff0055;
            --warning: #ffcc00;
            --bg: #0a0a12;
            --ui-bg: rgba(0, 20, 40, 0.85);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
        }

        /* Full Screen Canvas */
        canvas {
            display: block;
        }

        /* UI Overlay Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas */
        }

        /* HUD Elements */
        .hud-panel {
            position: absolute;
            padding: 15px;
            background: var(--ui-bg);
            border: 1px solid var(--primary);
            border-radius: 8px;
            pointer-events: auto;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
        }

        #stats-panel {
            top: 20px;
            left: 20px;
        }

        #wave-panel {
            top: 20px;
            right: 20px;
            text-align: right;
        }

        #controls-info {
            bottom: 20px;
            left: 20px;
            font-size: 0.9em;
            color: #aaa;
        }

        h2, h3, p { margin: 0; padding: 0 0 5px 0; }
        .value { font-weight: bold; font-size: 1.2em; color: var(--primary); }
        .danger { color: var(--danger); }

        /* Context Menu for Upgrades */
        #context-menu {
            display: none;
            position: absolute;
            background: var(--ui-bg);
            border: 2px solid var(--warning);
            padding: 10px;
            border-radius: 50%;
            width: 180px;
            height: 180px;
            pointer-events: auto;
            transform: translate(-50%, -50%); /* Center on cursor */
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #context-menu button {
            background: rgba(0,0,0,0.5);
            border: 1px solid white;
            color: white;
            cursor: pointer;
            padding: 5px 10px;
            margin: 5px;
            border-radius: 4px;
            font-size: 0.8em;
            transition: all 0.2s;
        }

        #context-menu button:hover {
            background: var(--primary);
            color: black;
        }

        /* Overlay Screens */
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 200;
        }

        #game-over-screen { display: none; }

        .btn-large {
            padding: 15px 40px;
            font-size: 1.5em;
            background: var(--primary);
            border: none;
            color: black;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            border-radius: 4px;
        }
        .btn-large:hover { background: white; box-shadow: 0 0 20px var(--primary); }

    </style>
</head>
<body>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div id="stats-panel" class="hud-panel">
            <h3>BASE STATUS</h3>
            <p>Integrity: <span id="health-display" class="value">100</span>%</p>
            <p>Scrap: <span id="scrap-display" class="value">100</span></p>
        </div>

        <div id="wave-panel" class="hud-panel">
            <h3>SYSTEM ALERT</h3>
            <p>Wave: <span id="wave-display" class="value">1</span></p>
            <p>Enemies: <span id="enemy-count" class="value">0</span></p>
        </div>

        <div id="controls-info" class="hud-panel">
            <p>Click <b>Defense Ring</b> to place Turret (50 Scrap)</p>
            <p>Click <b>Turret</b> to Upgrade/Sell</p>
        </div>

        <!-- Radial Context Menu -->
        <div id="context-menu">
            <div style="text-align:center; margin-bottom: 5px; font-weight:bold; color:var(--warning)">TURRET OPS</div>
            <button id="btn-upgrade-dmg">Upgrade DMG (75)</button>
            <button id="btn-upgrade-rng">Upgrade Range (50)</button>
            <button id="btn-sell" style="border-color: var(--danger)">Scrap (+25)</button>
            <button id="btn-close">Close</button>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1 style="font-size: 3em; color: var(--primary); text-shadow: 0 0 20px var(--primary);">ORBITAL SIEGE</h1>
        <p>Defend the core. Build turrets on the ring.</p>
        <button class="btn-large" onclick="startGame()">INITIATE DEFENSE</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen">
        <h1 style="color: var(--danger); font-size: 3em;">CRITICAL FAILURE</h1>
        <p>Waves Survived: <span id="final-wave" class="value">0</span></p>
        <button class="btn-large" onclick="resetGame()">REBOOT SYSTEM</button>
    </div>

    <script>
        // --- CONSTANTS & CONFIG ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Colors
        const C_PRIMARY = '#00f3ff';
        const C_ENEMY = '#ff0055';
        const C_BASE = '#ffffff';
        const C_RING = 'rgba(0, 243, 255, 0.2)';
        const C_RING_HOVER = 'rgba(0, 243, 255, 0.5)';

        // Game Balance
        const BASE_RADIUS = 30;
        const ORBIT_RADIUS = 150; // Distance from center where turrets go
        const TURRET_RADIUS = 15;
        const TURRET_COST = 50;
        
        // State
        let gameRunning = false;
        let lastTime = 0;
        let width, height, centerX, centerY;
        
        // Entity Lists
        let turrets = [];
        let enemies = [];
        let projectiles = [];
        let particles = [];
        
        // Player Stats
        let baseHealth = 100;
        let scrap = 100;
        let wave = 1;
        let score = 0;
        
        // Inputs
        let mouseX = 0;
        let mouseY = 0;
        let selectedTurret = null; // For context menu

        // Wave Logic
        let waveTimer = 0;
        let spawnRate = 2000; // ms
        let lastSpawn = 0;

        // --- MATH UTILITIES ---
        
        /**
         * Calculates distance between two points (x1,y1) and (x2,y2).
         * Uses Pythagorean theorem: c = sqrt(a^2 + b^2)
         */
        function getDistance(x1, y1, x2, y2) {
            const dx = x1 - x2;
            const dy = y1 - y2;
            return Math.sqrt(dx * dx + dy * dy);
        }

        /**
         * Returns the angle in radians from point 1 to point 2.
         * Math.atan2(y, x) handles all quadrants correctly.
         */
        function getAngle(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        }

        // --- CLASSES ---

        class Base {
            constructor() {
                this.maxHealth = 100;
                this.flashTime = 0;
            }

            draw() {
                // Draw Base
                ctx.beginPath();
                ctx.arc(centerX, centerY, BASE_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = this.flashTime > 0 ? '#fff' : '#222';
                ctx.strokeStyle = C_PRIMARY;
                ctx.lineWidth = 3;
                ctx.fill();
                ctx.stroke();

                // Inner core pulse
                const pulse = Math.sin(Date.now() / 200) * 5;
                ctx.beginPath();
                ctx.arc(centerX, centerY, BASE_RADIUS / 2 + pulse, 0, Math.PI * 2);
                ctx.fillStyle = C_PRIMARY;
                ctx.globalAlpha = 0.5;
                ctx.fill();
                ctx.globalAlpha = 1.0;

                if (this.flashTime > 0) this.flashTime--;
            }

            takeDamage(amount) {
                baseHealth -= amount;
                this.flashTime = 5;
                updateUI();
                createExplosion(centerX, centerY, 10, C_PRIMARY);
                if (baseHealth <= 0) gameOver();
            }
        }

        class Turret {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = getAngle(0, 0, x - centerX, y - centerY); // Face outward initially
                
                // Stats
                this.range = 250;
                this.damage = 10;
                this.fireRate = 500; // ms
                this.lastShot = 0;
                
                // Visual
                this.barrelLen = 20;
                this.color = '#0f0';
            }

            update(time) {
                // 1. Find Target
                let nearest = null;
                let minDst = Infinity;

                // Loop through enemies to find closest one
                for (let e of enemies) {
                    const d = getDistance(this.x, this.y, e.x, e.y);
                    if (d < this.range && d < minDst) {
                        minDst = d;
                        nearest = e;
                    }
                }

                // 2. Rotate & Fire
                if (nearest) {
                    // Update Angle: Trigonometry to point at enemy
                    this.angle = getAngle(this.x, this.y, nearest.x, nearest.y);

                    // Fire logic
                    if (time - this.lastShot > this.fireRate) {
                        this.fire(nearest);
                        this.lastShot = time;
                    }
                }
            }

            fire(target) {
                // Spawn projectile at tip of barrel
                // Use Sin/Cos to convert Angle + Length into X/Y offset
                const spawnX = this.x + Math.cos(this.angle) * this.barrelLen;
                const spawnY = this.y + Math.sin(this.angle) * this.barrelLen;
                
                projectiles.push(new Projectile(spawnX, spawnY, target, this.damage));
                
                // Recoil visual
                this.barrelLen = 15; 
                setTimeout(() => this.barrelLen = 20, 50);
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Draw Range (only if mouse nearby)
                const dMouse = getDistance(mouseX, mouseY, this.x, this.y);
                if (dMouse < TURRET_RADIUS + 10) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.range, 0, Math.PI*2);
                    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                    ctx.stroke();
                }

                ctx.rotate(this.angle);

                // Base
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(0, 0, TURRET_RADIUS, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Barrel
                ctx.fillStyle = '#666';
                ctx.fillRect(0, -5, this.barrelLen, 10);
                
                ctx.restore();
            }
        }

        class Enemy {
            constructor(waveNum) {
                // Spawn at random edge
                const side = Math.floor(Math.random() * 4);
                if (side === 0) { this.x = Math.random() * width; this.y = -20; } // Top
                if (side === 1) { this.x = width + 20; this.y = Math.random() * height; } // Right
                if (side === 2) { this.x = Math.random() * width; this.y = height + 20; } // Bottom
                if (side === 3) { this.x = -20; this.y = Math.random() * height; } // Left

                this.speed = 0.5 + (waveNum * 0.1);
                this.hp = 20 + (waveNum * 5);
                this.maxHp = this.hp;
                this.radius = 12;
                this.value = 5 + waveNum;
            }

            update() {
                // Move towards center
                const angle = getAngle(this.x, this.y, centerX, centerY);
                
                // Vector math: add velocity (cos/sin of angle) to position
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;

                // Hit base?
                const distToBase = getDistance(this.x, this.y, centerX, centerY);
                if (distToBase < BASE_RADIUS + this.radius) {
                    base.takeDamage(10);
                    this.hp = 0; // Destroy self
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Face center
                const angle = getAngle(this.x, this.y, centerX, centerY);
                ctx.rotate(angle);

                // Triangle shape
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.lineTo(-8, 8);
                ctx.lineTo(-8, -8);
                ctx.closePath();
                ctx.fillStyle = C_ENEMY;
                ctx.fill();

                // Health bar
                const pct = this.hp / this.maxHp;
                ctx.fillStyle = 'red';
                ctx.fillRect(-10, -15, 20, 3);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(-10, -15, 20 * pct, 3);

                ctx.restore();
            }
        }

        class Projectile {
            constructor(x, y, target, damage) {
                this.x = x;
                this.y = y;
                this.damage = damage;
                this.speed = 8;
                this.target = target; // Homing slightly
                this.angle = getAngle(x, y, target.x, target.y);
                this.active = true;
            }

            update() {
                if (!this.active) return;

                // Simple homing logic (adjust angle slightly towards target)
                if (this.target && this.target.hp > 0) {
                    const targetAngle = getAngle(this.x, this.y, this.target.x, this.target.y);
                    // Smooth turn (lerp angle) or just recalculate directly for perfect accuracy
                    this.angle = targetAngle; 
                }

                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;

                // Check collisions
                for (let e of enemies) {
                    if (getDistance(this.x, this.y, e.x, e.y) < e.radius + 5) {
                        e.hp -= this.damage;
                        this.active = false;
                        createExplosion(this.x, this.y, 3, '#ffcc00');
                        if (e.hp <= 0) {
                            scrap += e.value;
                            score += e.value;
                            updateUI();
                            createExplosion(e.x, e.y, 15, C_ENEMY);
                        }
                        break;
                    }
                }

                // Cleanup if out of bounds
                if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                    this.active = false;
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#ffcc00';
                ctx.fill();
                
                // Trail
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - Math.cos(this.angle)*10, this.y - Math.sin(this.angle)*10);
                ctx.strokeStyle = 'rgba(255, 204, 0, 0.5)';
                ctx.stroke();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const a = Math.random() * Math.PI * 2;
                const s = Math.random() * 2 + 0.5;
                this.vx = Math.cos(a) * s;
                this.vy = Math.sin(a) * s;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 3, 3);
                ctx.globalAlpha = 1.0;
            }
        }

        function createExplosion(x, y, count, color) {
            for(let i=0; i<count; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        const base = new Base();

        // --- CORE GAME LOOP ---

        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            // Mouse tracking
            window.addEventListener('mousemove', e => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            // Interaction
            canvas.addEventListener('click', handleInput);

            // Context Menu Bindings
            document.getElementById('btn-close').onclick = closeMenu;
            document.getElementById('btn-upgrade-dmg').onclick = () => upgradeTurret('dmg');
            document.getElementById('btn-upgrade-rng').onclick = () => upgradeTurret('rng');
            document.getElementById('btn-sell').onclick = sellTurret;

            updateUI();
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            centerX = width / 2;
            centerY = height / 2;
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            
            // Reset Game
            baseHealth = 100;
            scrap = 150;
            wave = 1;
            turrets = [];
            enemies = [];
            projectiles = [];
            particles = [];
            gameRunning = true;
            updateUI();
            
            loop(0);
        }

        function resetGame() {
             startGame();
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('final-wave').innerText = wave;
        }

        function loop(timestamp) {
            if (!gameRunning) return;

            const dt = timestamp - lastTime;
            lastTime = timestamp;

            ctx.fillStyle = 'rgba(10, 10, 18, 0.4)'; // Trails effect
            ctx.fillRect(0, 0, width, height);

            // 1. Draw Environment
            drawOrbitRing();
            base.draw();

            // 2. Game Logic: Spawning
            if (timestamp - lastSpawn > spawnRate) {
                enemies.push(new Enemy(wave));
                lastSpawn = timestamp;
                // Ramp up difficulty
                if (enemies.length > wave * 5) {
                    wave++;
                    spawnRate = Math.max(500, spawnRate - 100);
                    updateUI();
                }
            }

            // 3. Updates & Draws
            
            // Turrets
            turrets.forEach(t => { t.update(timestamp); t.draw(); });

            // Enemies
            enemies = enemies.filter(e => e.hp > 0);
            enemies.forEach(e => { e.update(); e.draw(); });

            // Projectiles
            projectiles = projectiles.filter(p => p.active);
            projectiles.forEach(p => { p.update(); p.draw(); });

            // Particles
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => { p.update(); p.draw(); });

            requestAnimationFrame(loop);
        }

        // --- DRAWING HELPERS ---

        function drawOrbitRing() {
            const dist = getDistance(mouseX, mouseY, centerX, centerY);
            const onRing = Math.abs(dist - ORBIT_RADIUS) < 15;

            ctx.beginPath();
            ctx.arc(centerX, centerY, ORBIT_RADIUS, 0, Math.PI * 2);
            ctx.strokeStyle = onRing ? C_RING_HOVER : C_RING;
            ctx.lineWidth = onRing ? 3 : 1;
            ctx.setLineDash([10, 10]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Ghost turret
            if (onRing && scrap >= TURRET_COST && !selectedTurret) {
                // Snap angle to mouse
                const angle = getAngle(centerX, centerY, mouseX, mouseY);
                const tx = centerX + Math.cos(angle) * ORBIT_RADIUS;
                const ty = centerY + Math.sin(angle) * ORBIT_RADIUS;
                
                ctx.beginPath();
                ctx.arc(tx, ty, TURRET_RADIUS, 0, Math.PI*2);
                ctx.strokeStyle = C_PRIMARY;
                ctx.stroke();
            }
        }

        // --- INPUT & LOGIC ---

        function handleInput(e) {
            if (!gameRunning) return;
            if (selectedTurret) {
                closeMenu();
                return;
            }

            const rX = e.clientX;
            const rY = e.clientY;
            
            // Check if clicked existing turret
            for(let t of turrets) {
                if (getDistance(rX, rY, t.x, t.y) < TURRET_RADIUS + 5) {
                    openMenu(t, rX, rY);
                    return;
                }
            }

            // Check if clicked Ring for placement
            const dist = getDistance(rX, rY, centerX, centerY);
            if (Math.abs(dist - ORBIT_RADIUS) < 20) {
                if (scrap >= TURRET_COST) {
                    // Check overlap
                    // Calculate exact position on ring based on angle
                    const angle = getAngle(centerX, centerY, rX, rY);
                    const tx = centerX + Math.cos(angle) * ORBIT_RADIUS;
                    const ty = centerY + Math.sin(angle) * ORBIT_RADIUS;

                    // Prevent stacking
                    const tooClose = turrets.some(t => getDistance(tx, ty, t.x, t.y) < TURRET_RADIUS * 2.2);
                    
                    if (!tooClose) {
                        turrets.push(new Turret(tx, ty));
                        scrap -= TURRET_COST;
                        updateUI();
                        createExplosion(tx, ty, 5, C_PRIMARY);
                    }
                }
            }
        }

        // --- UPGRADE MENU LOGIC ---

        const menu = document.getElementById('context-menu');

        function openMenu(turret, screenX, screenY) {
            selectedTurret = turret;
            menu.style.display = 'flex';
            menu.style.left = screenX + 'px';
            menu.style.top = screenY + 'px';
        }

        function closeMenu() {
            selectedTurret = null;
            menu.style.display = 'none';
        }

        function upgradeTurret(type) {
            if (!selectedTurret) return;
            
            if (type === 'dmg') {
                if (scrap >= 75) {
                    scrap -= 75;
                    selectedTurret.damage += 5;
                    selectedTurret.color = '#f0f'; // Visual change
                    createExplosion(selectedTurret.x, selectedTurret.y, 5, '#f0f');
                }
            } else if (type === 'rng') {
                if (scrap >= 50) {
                    scrap -= 50;
                    selectedTurret.range += 50;
                    createExplosion(selectedTurret.x, selectedTurret.y, 5, '#fff');
                }
            }
            updateUI();
            closeMenu();
        }

        function sellTurret() {
            if (!selectedTurret) return;
            scrap += 25;
            turrets = turrets.filter(t => t !== selectedTurret);
            updateUI();
            closeMenu();
        }

        function updateUI() {
            document.getElementById('health-display').innerText = Math.max(0, baseHealth);
            document.getElementById('scrap-display').innerText = scrap;
            document.getElementById('wave-display').innerText = wave;
            document.getElementById('enemy-count').innerText = enemies.length;
            
            // Low health warning
            const hpText = document.getElementById('health-display');
            if (baseHealth < 30) hpText.classList.add('danger');
            else hpText.classList.remove('danger');
        }

        // --- STARTUP ---
        init();

    </script>
</body>
</html>